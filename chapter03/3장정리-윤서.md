# 3장. 다른 개발자와 코드 계약



## 3.1 자신의 코드와 다른 개발자의 코드

- 다른 개발자들은 여러분들이 전혀 생각지 못한 완전히 다른 문제에서 여러분이 작성한 하위 문제 해결 코드를 재사용할 수 있다.
- 우선순위가 변경되고, 새로운 기능이 추가되어야 하며 시스템은 때로 새로운 기술 환경으로 옮겨져야 한다.

- 고품질 코드를 작성할 때 가장 중요한 고려 사항 중 하나는 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지, 또 발생한다면 그 문제를 어떻게 완화할 수 있을지를 이해하고 선제적으로 조치하는 것이다.
- 자신이 작성한 코드가 독립적으로 존재하는 경우는 거의 없다. 다른 개발자들이 작성한 코드에 의존할 것이고, 다른 엔지니어들 또한 여러분의 코드에 의존하는 코드를 작성할 것이다.
- 코드를 작성할 때 다음 세 가지를 고려하는 것이 유용하다.
  - 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.
  - 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.
  - 시간이 지남에 따라 자신의 코드를 기억하지 못한다.



### 3.1.1 자신에게 명백하다고 해서 다른 사람에게도 명백한 것은 아니다.

- 여러분의 코드를 변경하거나 여러분의 코드가 의존하는 코드를 변경해야 할 수도 있다는 것을 기억해야 한다.
- 그들은 그 문제를 이해하고 어떻게 해결할지에 대해 생각할 수 있는 시간을 아직 충분히 갖지 못한 상태다.
- 여러분이 코드를 작성할 당시에 너무도 분명해 보였던 것들이 그들에게는 분명하지 않았을 것이다.
- 이것을 항상 고려하고 코드가 어떻게 사용되어야 하는지, 무엇을 하는지, 그리고 왜 그 일을 하고 있는지 설명하는 것이 유용하다.
- 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.



### 3.1.2 다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다.

- 여러분이 작성한 코드는 다른 코드로부터 전혀 영향을 받지 않은 채 독립적으로 있는 것이 아니라, 끊임없이 변화하는 코드 위에 놓여있고, 여러분의 코드를 기반으로 계속해서 변화하는 코드 역시 끊임없이 작성된다.
- 무언가 문제가 있을 때 코드 컴파일이 중지되거나 테스트가 실패하도록 만드는 것이다.



### 3.1.3. 시간이 지나면 자신의 코드를 기억하지 못한다.

- 자신의 코드를 작동하지 않게 만드는 것과 관련해 살펴본 모든 내용이 어느 순간 자신에게 적용된다.
- 배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬워야 하고, 잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다.



## 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

- 다음 사항을 이해할 필요가 있다.
  - 여러 가지 상황에서 어떤 함수를 호출해야 하는지
  - 클래스가 무엇을 나타내는지 그리고 언제 사용되어야 하는지
  - 어떤 값을 인수로 사용해야 하는지
  - 코드가 수행하는 동작이 무엇인지
  - 어떤 값을 반환하는지
- 이를 위해 다른 개발자가 할 수 있는 일은 다음과 같다.
  - 함수, 클래스, 열거형 등의 이름을 살펴본다.
  - 함수와 생성자의 매개변수 유형 또는 반환값의 유형 같은 데이터 유형을 살펴본다.
  - 함수/클래스 수준의 문서나 주석문을 읽어본다.
  - 직접 와서 묻거나 채팅/이메일을 통해 문의한다.
  - 여러분이 작성한 함수와 클래스의 자세한 구현 코드를 읽는다.



### 3.2.1 이름 확인

- 이름들을 살펴보는 것은 하위 문제를 해결할 코드를 찾기 위한 편리하고 빠른 방법이다.
- 따라서 자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법 중 하나는 이름을 잘 짓는 것이다.



### 3.2.2 데이터 유형 확인

- 제대로만 한다면 데이터 유형을 확인하는 것 역시 다른 개발자로 하여금 자신의 코드를 올바르게 사용하도록 하기 위한 매우 신뢰할 만한 방법이다.
- 타입 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법 중 하나다.



### 3.2.3 문서 읽기

- 코드를 사용하는 방법에 관한 문서는 다음과 같다.
  - 함수 및 클래스 수준의 비공식적인 주석문
  - 자바독과 같은 좀 더 공식적인 코드 내 문서
  - 외부 문서(README.md, 웹 페이지, 지침 문서 등)
- 모두 유용하지만 어느정도만 신뢰할 수 있다.
  - 다른 개발자가 문서를 읽는다는 보장이 없고 실제로 읽지 않을 때가 많다.
  - 설령 읽더라도 잘못 해석할 수 있다.
  - 문서의 업데이트가 제대로 안될 수 있다.



### 3.2.4 직접 물어보기

- 코드를 작성한 지 얼마되지 않았다면 이 접근법이 상당히 효과적일 수 있다.
- 그러나 코드의 사용법을 설명하기엔 신뢰하기 어려운 방법이다.
  - 코드를 많이 작성할 수록 질문에 답하는 데 더 많은 시간을 써야 할 것이다.
  - 코드 작성자가 2주간 휴가를 간다면 코드에 대해 물어볼 사람이 없다.
  - 1년이 지나면 자기 자신도 코드를 기억하지 못한다. 제한된 기간 동안만 효과가 있다.
  - 코드를 작성한 사람이 퇴사하는 경우 지식이 사라져 버린다.



### 3.2.5 코드를 살펴 보는 것

- 가장 확실한 답을 얻을 수 있는 방법은 코드의 자세한 구현 세부사항을 살펴보는 것이다.
- 이 접근법은 실용적이지 않고 코드의 양이 많으면 효과를 얻기 힘들다.
- 한 의존 코드는 또다시 다른 코드에 의존하기 때문에 이런 상황에서는 일부 또는 모든 하위 의존 코드의 구현 세부사항을 읽어야할 것이고, 이런 하위 의존 라이브러리의 수가 족히 수백개는 될 것이다.
- 추상화 계층을 만드는 데 있어 요점은 개발자가 한 번에 몇 가지 개념만 처리해야 하고, 그 문제가 어떻게 해결되었는지 정확히 알지 못하더라도 하위 문제에 대한 해결책을 사용할 수 있어야 한다는 것이다.
- 코드를 사용하는 방법을 알기 위해 개발자가 구현 세부 사항을 읽어야 한다면 이는 분명히 추상화 계층의 많은 이점을 부정하는 것이 된다.



## 3.3 코드 계약

- 계약에 의한 프로그래밍 또는 계약에 의한 디자인은 다른 사람들이 이 코드를 어떻게 사용할지, 코드가 무엇을 할 것으로 기대할 수 있는지에 대한 것이다.
- 코드의 계약에 대한 용어는 3가지 범주로 나뉜다.
  - **선결 조건(precondition)** : 코드를 호출하기 전에 사실이어야 하는 것. 시스템이 어떤 상태에 있어야 하는지, 코드에 어떤 입력을 공급해야 하는지와 같은 사항
  - **사후 조건(postcondition)** : 코드가 호출된 후에 사실이어야 하는 것. 시스템이 새로운 상태에 놓인다든지 반환되는 값과 같은 사항
  - **불변 사항(invariant)** : 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

- 입력 매개변수가 있는 함수를 작성하거나, 값을 반환하거나, 어떤 상태를 수정하면 이것은 계약을 생성한 것이 되는데, 그 이유는 코드를 호출하는 사람에게 무언가를 설정하거나 입력(선결 조건)을 제공해야 할 요건을 부여하고, 호출 결과가 일어날 일 혹은 반환될 값(사후 조건)에 대한 기대를 갖게 하기 때문이다.
- 개발자가 계약의 일부 혹은 모든 조건을 알지 못하면 코드 계약에 문제가 발생한다. 코드를 작성할 때, 만들어지는 계약의 내용이 무엇일지 그리고 어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대해 생각하는 것이 중요하다.



### 3.3.1 계약의 세부 조항

- 계약의 명확한 부분
  - 함수와 클래스 이름
  - 인자 유형
  - 반환 유형
  - 검사 예외(checked exception)
- 세부 조항
  - 주석문과 문서
  - 비검사 예외(unchecked exception)
- 코드 계약에서 조건을 명백하게 하는 것이 세부 조항을 사용하는것 보다 훨씬 낫다.
- 문서화는 업데이트가 제때 되지 않기 때문에 세부 조항이 항상 정확한 것도 아니다.



### 3.3.2 세부 조항에 너무 의존하지 말라

- 코드 계약을 전달할 때 세부 조항을 사용하는 것은 신뢰할 만한 방법이 아니다.
- 시간이 흐르면서 업데이트가 안될 가능성이 크기 때문에 문서화는 아주 이상적인 방법은 아니다.
- 명확하지 않을 수도 있는 사항들을 문서화하는 것은 일반적으로 좋은 생각이지만, 너무 많이 의존하지 않는 것이 최선의 방법이다.
- 코드 계약의 분명한 항목을 통해 코드에 관해 명확하게 설명하는 것이 가능하다면 그렇게 하는 것이 더 바람직할 때가 많다.
- 세부조항에 의존하기 보다는 잘못된 일을 하는 것을 처음부터 불가능하게 만드는 것이 좋다.
- 코드 계약의 세부 조항에 있는 어떤 항목에 대해 발생 자체가 불가능하도록(또는 실수할 가능성이 없도록 하는) 명백한 항목으로 바꾸는 것이 가능한 경우가 있다.
- 코드가 어떤 상태에 들어갈 수 있는지 혹은 입력이나 반환으로 어떤 데이터 유형을 취할 수 있는지 신중하게 생각해보면 이렇게 변경하는 것이 가능할 때가 있다.
- 코드가 오용되거나 잘못 설정되면 컴파일조차 되지 않도록 하는 것이 목표다.
- 여기에 사용된 기법이 어떤 상태나 가변성이 클래스 외부로 노출되는 것을 없앤다는 점을 알아챘을 것이다.
- 코드 품질을 향상시키기 위한 많은 방법은 이 두가지를 최소화하는 것과 관련이 있다.
- 객체의 상태는 객체가 담고 있는 어떤 값이나 데이터를 말한다. 객체를 만든 후 이러한 객체의 상태를 수정할 수 있으면 이 객체는 가변적이라 한다.
- 반대로 객체를 생성한 후에 상태를 변경할 수 없다면 이 객체는 불변적이라고 한다.



## 3.4 체크 및 어서션

- 컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.
- 컴파일 타임 확인만큼 강력하지 않은데, 왜냐면 코드 계약 위반의 발견이 코드를 실행하는 동안 발생하는 문제에 대한 테스트(또는 사용자)에 의존하기 때문이다.
- 이는 애당초 계약 위반을 논리적으로 불가능하게 만드는 컴파일 타임 확인과는 대조적이다.



### 3.4.1 체크

- 코드 계약 조건을 확인하기 위한 일반적인 방법은 체크를 사용하는 것이다.
- 이것은 코드 계약이 준수되었는지 확인하기 위한 추가적인 로직이며 준수되지 않을 경우 체크는 실패를 유발하는 오류를 생성하는데, 이 실패는 명백해서 놓치고 넘어가는 것이 불가능하다.
- 체크는 시행 중인 계약 조건에 따라 다음과 같은 범주로 구분된다.
  - 전제 조건 검사: 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
  - 사후 상태 검사: 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

- 일부 언어에서는 체크를 언어 자체에서 제공하기 때문에 구문적으로 더 낫지만, 체크를 제공하지 않는 다른 언어는 좀 더 수동적인 접근 방식이나 타사 라이브러리를 사용해야 한다.
- 체크를 사용할 때 기대하는 것은 코드가 오용되면 고객에게 배포되거나 실제 프로덕션에서 서비스되기 전에 개발 단계나 테스트 단계에서 발견되고 수정되는 것이다.
  - 테스트하기가 불분명한 상황에서만 확인 중인 조건이 위반된다면(또는 퍼즈 테스트가 시뮬레이션 되지 않는 경우), 코드가 배포되고 사용자가 사용하기 전까지 버그가 노출되지 않을 수 있다.
  - 체크가 잘 작동해서 실패가 명백함에도 불구하고 아무도 알아차리지 못할 위험이 있다. 예외가 일어나더라도 시스템이 작동을 완전히 멈추지 않도록 하기 위해 프로그램의 상위 수준에서 예외가 처리되고 오류의 자세한 사항이 로그에 기록될 수 있다.
- 경우에 따라 코드 계약에서 세부 조항을 피할 수 없으며, 이때는 계약이 준수되는지 확인하기 위해 체크를 추가하는 것이 좋다.
- 하지만 가능하다면 처음부터 세부 조항은 피하는 것이 바람직하다. 코드에 체크가 많이 있으면 세부 조항을 없애는 것에 대해 고려해봐야 한다는 신호일지도 모른다.



### 퍼즈 테스트

- 코드나 소프트웨어의 버그나 잘못된 설정을 드러낼 수 있는 입력값을 생성해 테스트를 수행하는 테스트의 한 종류다.
- 퍼즈테스트를 사용하는 경우 체크(또는 어서션)를 함께 사용하면 잘못된 설정이나 버그를 발견할 가능성을 높이는 데 도움이 된다.
- 왜냐하면 퍼즈 테스트는 오류나 예외 발생에 의존하며 이것만으로는 단순히 이상한 동작을 초래하는 미묘한 버그를 발견할 수 없기 때문이다.



### 3.4.2 어서션

- 많은 언어에서 어서션(assertion)을 언어 차원에서 지원한다. 어서션은 코드 계약을 준수하도록 강제하기 위한 방법이라는 점에서 체크와 매우 유사하다.

- 조건이 위반되면 오류가 명백하게 보이거나 예외가 발생한다.
- 어서션과 체크 사이의 주요 차이점은 배포를 위해 빌드할 때 어서션은 보통 컴파일에서 제외된다는 점이며, 이는 코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 것을 의미한다.
- 코드를 배포할 때 컴파일 하지 않는 이유
  - 성능 향상을 위해: 코드에서 어서션이 많으면 전반적인 성능이 저하될 수 있다.
  - 코드 오류 발생률을 낮추기 위해: 버그가 눈에 띄지 않을 가능성이 증가하지만 버그 발생 가능성 바잊보다 고가용성이 더 중요한 시스템이라면 배포 시에 컴파일에서 제외하는 것은 적절한 절충이 될 수 있다.
- 코드의 배포를 위한 빌드에서도 어서션을 사용할 수 있는 방법이 있으며 많은 개발팀이 이렇게 한다.
- 이 경우 어서션은 체크와 다르지 않고, 다만 어떤 종류의 오류나 예외를 발생시킬 수 있는지에 대한 일부 세부 사항이 조금 다를 뿐이다.