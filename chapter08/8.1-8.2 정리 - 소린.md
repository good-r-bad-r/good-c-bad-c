# 8. 코드를 모듈화하라

- 요구사항이 어떻게 바뀔지 정확히 예측하는 것은 대게 시간 낭비인데, 그 이유는 정확하게 예측하는 것이 거의 불가능하기 때문이다. 하지만 보통 요구사항이 어떤식으로든 바뀐다는 점만은 어느 정도 확신할 수 있다.
- 모듈화의 주된 목적 중 하나는 코드가 향후에 어떻게 변경되거나 재구성될지 정확히 알지 못한 상태에서 변경과 재구성이 용이한 코드를 작성하는 것이다.
- 요구사항 중 하나가 변경된다면, 코드베이스에서 그 요구 사항이나 기능과 관련된 부분만 수정하면 된다.

## 8.1 의존성 주입의 사용을 고려하라

- 하위 문제에 대해 해결책이 항상 하나만 존재하는 것은 아니므로, 하위 문제를 재구성 할 수 있는 방식으로 코드를 작성하는 것이 유용할 수 있다.

### 8.1.1 하드 코드화된 의존성은 문제가 될 수 있다.

- RoutePlanner 클래스는 이제 NorthAmericaRoadMap 클래스에만 적용되는 개념(최신 지도를 얻기 위해 서버에 연결할지 여부 및 계절별 도로 포함 여부)을 처리해야 한다. 이로 인해 추상화 계층이 지저분해지고 코드의 적응성이 한층 더 제한될 수 있다.

### 8.1.2 해결책: 의존성 주입을 사용하라

- RoutePlanner 클래스의 인스턴스를 생성할 때 다른 로드랩도 허용된다면 클래스는 훨씬 더 모듈화되고 다용도로 쓰일 수 있다. 생성자의 매개변수를 통해 로드랩을 제공함으로써 RoadMap을 주입하면 이를 달성할 수 있다.
- 중요한 점은 의존성 주입 프레임 워크를 사용하면 팩토리 함수의 반복적인 코드를 작성하느라 허우적대지 않고, 대신 매우 모률화되고 다용도로 사용할 수 있는 코드를 만들 수 있다는 점이다.

### 8.1.3 의존성 주입을 염두에 두고 코드를 설계하라

- 코드를 작성할 때 의존성 주입을 사용할 수 있다는 점을 의식적으로 고려하는 것이 유용할 때가 있다. 코드를 작성하다 보면 나중에 의존성 주입을 사용하고 싶어도 사용이 거의 불가능한 코드가 짜여질 수 있기 때문에 이후에 의존성 주입을 사용할 가능성이 있다면 이런 방식으로 코드를 작성하는 것은 피해야한다.
- 하나의 해결책만 있는 아주 근본적인 하위 문제라면 이렇게해도 일반적으로 문제가 없다. 그러나 상위 코드 계층에서 하위 문제에 대해 설정을 달리하고자 한다면 문제가 될수있다.
- 의존성 주입은 코드를 모듈화하고 다른 시나리오에도 적용할 수 있게 해주는 훌륭한 방법이다. 하위 문제에 대한 해결책이 여러 개 있는 경우에는 의존성 주입이 특별히 중요할 수 있다.

## 8.2 인터페이스에 의존하라

### 8.2.1 구체적인 구현에 의존하면 적응성이 제한된다

- 로드랩의 어떤 구현 클래스라도 사용 할 수 있으므로 코드가 훨씬 더 모듈화되고 적응성이 높아진다.
- 어떤 클래스에 의존하고 있는데 그 클래스가 어떤 인터페이스를 구현하고 필요한 기능이 그 인터페이스에 모두 정의되어 있으면, 클래스에 직접 의존하기보다는 인터페이스에 의존하는 것이 일반적으로 더 바람직하다.
- 그러나 이 코드는 의존성 주입을 사용할 때 얻을 수 있는 주된 이점 중 하나를 놓치고 있다. 즉, RoutePlanner 클래스를 RoadMap을 구현하는 다른 클래스에 대해서는 사용할 수 없다.

### 8.2.2 해결책: 가능한 경우 인터페이스에 의존하라

- 구체적인 구현 클래스에 의존하면 인터페이스를 의존할 때보다 적응성이 제한되는 경우가 많다.
- 클래스는 하위 문제를 해결하는 데 있어 추상적이지 않고 좀 더 구현 중심적인 방식으로 해결한다. 더 추상적인 인터페이스에 의존하면 대개의 경우 더 간결한 추상화 계층과 더 나은 모률화를 달성할 수 있다.
- 클래스가 인터페이스를 구현하고 이 인터페이스가 필요한 동작을 정의한다면 이것은 곧 다른 개발자가 해당 인터페이스에 대해 다르게 구현한 클래스를 작성할 수 있다는 것을 강하게 시사한다.
