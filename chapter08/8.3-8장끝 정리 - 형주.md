## 8.3 클래스 상속을 주의하라
- 객체 지향 프로그래밍 언어의 핵심 기능 중 하나는 한 클래스가 다른 클래스를 상속할 수 있는 것이다.
- 클래스는 다른 클래스를 상속할 수 있고 이렇게 해서 클래스 계층이 형성된다.
- 두 가지 사물이 진정한 is-a 관계를 갖는다면(ex. car is a vehicle) 상속이 적절할 수 있다. 하지만 상속은 몇가지 단점이 있고 상속이 야기하는 무넺가 치명적일 수 있기 때문에 신중하게 생각해봐야 한다.
- 상속을 사용할 수 있는 많은 상황에서 구성(Composition)을 대신 사용할 수 있다. 상속의 함정을 피할 수 있고 모듈화와 내구성이 향상된 코드를 작성할 수 있다.

### 8.3.1 클래스 상속은 문제가 될 수 있다.
- 클래스 상속을 통해서는 한 인터페이스에만 의존하는 것이 허용되지 않는다.
- 상속의 주요 특징 중 하나는 서브클래스가 슈퍼클래스에 의해 제공되는 모든 기능을 상속한다는 점이다.
- 상속은 추상화 계층에 방해가 될 수 있다.
  - 한 클래스가 다른 클래스를 확장하면 슈퍼클래스의 모든 기능을 상속한다.
  - 원하는 것보다 더 많은 기능을 노출할 수 도 있다. 이로 인해 추상화 계층이 복잡해지고 구현 세부 정보가 드러날 수 있다.
  - 클래스의 일부 기능을 외부로 개방하는 경우 적어도 그 기능을 사용하는 개발자가 있을 것이라고 예상할 수 있다.
  - 사실은 구현 세부 사항이어야 하지만 상속을 통해 이 클래스의 함수들이 의도치 않게 외부에 공개된다.
- 상속은 적응성 높은 코드의 작성을 어렵게 만들 수 있다.
  - 살짝 바뀐 요구 사항을 반영해야 할 때 코드를 약간만 수정하면 될 것 같지만, 유감스럽게도 상속을 사용하는 경우에는 코드 변경이 간단치 않을 수 있다.

### 8.3.2 해결책: 구성(Composition)을 사용하라
- 클래스를 확장하기보다는 해당 클래스의 인스턴스를 가지고 있음으로써 하나의 클래스를 다른 클래스로부터 구성한다는 것을 의미한다.
- 추상화 계층이 더 간결해지고 코드는 재설정하기 쉬워진다.
- 생성자를 통해 의존성 주입으로 제공된다
- 구성을 사용하면 코드 재사용의 이점을 얻을 수 있고, 상속과 관련된 문제도 피할 수 있다.
- 더 간결한 추상화 계층
  - 상속을 사용할 때 서브클래스는 슈퍼클래스의 모든 기능을 상속하고 외부로 제공한다.
  - 상속 대신 구성을 사용하면 클래스가 전달이나 위임을 사용하여 명시적으로 노출하지 않는 한 클래스의 기능이 노출되지 않는다.

### 8.3.3 진정한 is-a관계는 어떤가?
- 두 클래스가 진정한 is-a 관계를 맺고 있다면 상속이 타당할 수 있다.
- 그러나 진정 is-a 관계일 때조차 상속이 좋은 접근법인지 명확하지 않을 수 있다.
- 답은 없고 주어진 상황과 작업중인 코드에 따라 다르지만 진정한 is-a 관계라도 상속이 여전히 문제가 될 수 있다는 점을 알고 있어야한다.
- 주의점
  - 취약한 베이스 클래스 문제: 서브클래스가 슈퍼클래스에서 상속되고 해당 슈퍼클래스가 나중에 수정되면 서브클래스가 작동하지 않을 수 있다. 따라서 코드를 변경할 때 그 변경이 문제없을지 판단하기가 어려운 경우가 있다.
  - 다이아몬드 문제: 일부 언어는 다중 상속을 지원한다. 여러 슈퍼클래스가 동일한 함수의 각각 다른 버전을 제공하는 경우 문제가 발생할 수 있는데, 어떤 슈퍼클래스로부터 해당 함수를 상속해야 하는지 모호하기 때문이다.
  - 문제가 있는 계층 구조: 많은 언어가 다중 상속을 지원하지 않으므로 클래스는 오직 하나의 클래스만 직접 확장할 수 있다. 이런 단일 상속은 클래스가 논리적으로 둘 이상의 클래스에 속할 때 문제가 될 수 있다.
- 클래스 상속에는 경계해야 할 함정이 많다. 많은 개발자들이 할 수 있는 한 상속을 피하고자 한다. 다행히도 구성과 인터페이스를 사용하면 상ㅅ곡의 단점은 피하면서 이점은 많이 얻을 수 있다.
- 계층 구조는 인터페이스를 사용하여 정의, 코드 재사용은 구성을 통해 달성할 수 있다.

## 8.4 클래스는 자신의 기능에만 집중해야 한다.
- 모듈화의 핵심 목표중 하나는 요구 사항이 변경되면 그 변경과 직접 관련된 코드만 수정한다는 것이다.
- 단일 개념이 단일 클래스 내에 완전히 포함된 경우라면 이 목표는 달성할 수 있다. 어떤 개념과 관련된 요구 사항이 변경되면 그 개념에 해당하는 단 하나의 클래스만 수정하면 된다.
- 반대되는 상황은 하나의 개념이 여러 클래스에 분산되는 경우다. 해당 개념과 관련된 요구 사항을 변경하려면 관련된 클래스를 모두 수정해야 한다. 이 때 개발자가 관련 클래스 중 하나를 잊어버리고 수정하지 않으면 버그가 발생할 수 있다. 클래스가 다른 클래스의 세부사항에 지나치게 연관되어 있을 때 이런 일이 흔히 일어날 수 있다.

### 8.4.1 다른 클래스와 지나치게 연관되어 있으면 문제가 될 수 있다.

### 8.4.2 해결책: 자신의 기능에만 충실한 클래스를 만들라.
- Book 클래스는 Chapter 클래스의 세부 사항을 다룰 필요가 없고 자기 자신만 신경쓰면 된다.
- 디미터의 법칙: 한 객체가 다른 객체의 내용이나 구조에 대해 가능한 한 최대한으로 가정하지 않아야 한다는 소프트웨어 공학의 원칙이다.
- 코드 모듈화를 위한 핵심 목적 중 하나는 요구 사항의 변경이 필요하면 해당 요구 사항과 직접 관련된 코드만 변경하고자 하는 것이다.
- 클래스는 서로에 대한 어느 정도의 지식을 필요로 할 때도 있지만, 가능한 한 이것을 최소화하는 것이 좋을 때가 많다. 이를 통해 코드 모듈화를 유지할 수 있으며 적응성과 유지관리성을 크게 개선할 수 있다.

## 8.5 관련 있는 데이터는 함께 캡슐화하라
- 서로 다른 데이터가 서로 밀접하게 연관되어 있어 그것들이 항상 함께 움직여야 할 때가 있다. 이 경우에는 클래스(또는 유사한 구조)로 그룹화 하는 것이 합리적이다.
- 이렇게 하면 코드는 여러 항목의 세부 사항을 다루는 대신, 그 항목들이 묶여 있는 단일한 클래스가 제공하는 상위 수준의 개념을 다룰 수 있다.
- 이를 통해 코드는 더욱 모듈화하고 변경된 요구 사항을 해당 클래스에서만 처리할 수 있다.

### 8.5.1 캡슐화되지 않은 데이터는 취급하기 어려울 수 있다.
- 모듈화의 목적 중 하나는 요구 사항의 변경이 있을 때 해당 요구 사항과 직접 관련 있는 코드만 수정하고자 하는 것이다.

### 8.5.2 해결책: 관련된 데이터는 객체 또는 클래스로 그룹화하라.
- 여러 데이터가 따로 떨어져서는 별 의미가 없을 정도로 서로 밀접하게 연관되어 있거나, 캡슐화된 데이터 중에서 일부만 원하는 경우가 아니라면 캡슐화하는 것이 합리적이다.

## 8.6 반환 유형에 구현 세부 정보가 유출되지 않도록 주의하라
- 간결한 추상화 계층을 가지려면 각 계층의 구현 세부 정보가 유출되지 않아야 한다.
- 구현 세부 정보가 유출되면 코드의 하위 계층에 대한 정보가 노출될 수 있으며, 향후 수정이나 재설정이 매우 어려워 질 수 있다.
- 코드에서 구현 세부 정보를 유출하는 일반적인 형태 중 하나는 해당 세부 정보와 밀접하게 연결된 유형을 반환하는 것이다.

### 8.6.1 반환 형식에 구현 세부 사항이 유출될 경우 문제가 될 수 있다.
- HttpFetcher가 사용된다는 사실은 구현 세부 사항이기 때문에 ProfilePictureService 클래스를 사용하는 개발자는 HttpFetcher가 사용된다는 사실을 알 필요가 없다.
- 다른 개발자가 ProfilePctureService 클래스를 사용하려면 HttpResponse와 관련된 여러 개념을 처리해야 한다.
- ProfilePictureService의 구현을 변경하는 것은 매우 어렵다.

### 8.6.2 해결책: 추상화 계층에 적합한 유형을 반환하라
- 클래스를 통해 제공하고자 하는 이상적인 추상화 계층과 모든 반환 형식은 이 점을 반영해야 한다.
- 클래스를 사용하는 다른 개발자에게 노출되는 개념이 최소가 되도록 노력해야 한다.
- 외부로 노출할 개념을 최소화하는 유형을 새로 정의해 사용하면 좀 더 모듈화된 코드와 간결한 추상화 계층을 얻을 수 있다.

## 8.7 예외 처리 시 구현 세부 사항이 유출되지 않도록 주의하라
### 8.7.1 예외 처리 시 구현 세부 사항이 유출되면 문제가 될 수 있다.
- 비검사 예외의 핵심 기능 중 하나는 예외가 발생하는 위치나 시기， 코드가 어디에서 그 예외를 처리 하는지 등에 대해 그 어떠한 것도 컴파일러에 의해 강제되지 않는다는 것이다.
- 비검사 예외에 대한 지 식은 코드 계약의 세부 조항을 통해 전달되지만 개발자가 문서화하는 것을 잊어버리면 코드 계약을 통해 전혀 전달되지 않는다.
- 추상화 계층 개념을 위반할 뿐만 아니라 신뢰할 수 없고 오류를 일으키기 쉽다.
- 구현 세부 정보가 유출될 위험이 비검사 예외에만 있는 것은 아니지만, 이 예에서 비검사 예외로 인 해 문제가 더욱 악화되어 발생한다.
- 비검사 예외를 발생할 수 있다는 점을 개발자가 문서화하지 않을 가능성이 크고, 인터페이스를 구현하는 클래스가 반드시 인터페이스가 규정하는 오류만 발생시켜야만 하는것은 아니다.

### 8.7.2 해결책: 추상화 계층에 적절한 예외를 만들라
- 구현 세부 사항의 유출을 방지하기 위해 코드의 각 계층은 주어진 추상화 계층을 반영하는 오류 유형만을 드러내는 것이 이상적이다.
- 검사 예외를 사용하여 명시적으로 오류를 전달하고 있다.
- 단점은 명백한데, 사용자 지정 예외 클래스를 정의하고, 이에 따라 다양한 예외를 처리하고, 예외를 감싼 후에 다시 발생시켜야 하기 때문에 코드 줄이 더 많아졌다는 점이다.
- 클래스의 동작이 예측 가능하고 모듈화가 개선된다는 장점을 비교하면, 단점을 통해 잃는 것보다는 장점을 통해 얻는 것이 훨씬 더 크다.

## 8장 요약
- 코드가 모듈화되어 있으면 변경된 요구 사항을 적용하기 위한 코드를 작성하기가 쉽다.
- 모듈화의 주요 목표 중 하나는 요구 사항의 변경이 해당 요구 사항과 직접 관련된 코드에만 영향 을 미치도록 하는 것이다.
- 코드를 모듈식으로 만드는 것은 간결한 추상화 계층을 만드는 것과 깊은 관련이 있다.
- 다음의 기술을 사용하여 코드를 모듈화할 수 있다.
  - 의존성 주입
  - 구체적인 클래스가 아닌 인터페이스에 의존
  - 클래스 상속대신 인터페이스 및 구성의 활용
  - 클래스는 자신의 기능만 처리
  - 관련된 데이터의 캡슐화
  - 반환유형 및 예외 처리 시 구현 세부 정보 유출 방지
