# 코드 품질



## 이 책이 다루는 내용

- 코드 품질이 중요한 이유
- 고품질의 코드가 이루고자 하는 네 가지 목표
- 고품질 코드 작성을 위한 높은 수준에서의 여섯 가지 전략
- 고품질의 코드 작성이 어떻게 중장기적으로 시간과 노력을 절약할 수 있는지



### 고품질 코드

- 고품질 코드는 일반적으로 좀 더 신뢰할 수 있고, 유지보수가 쉬우며, 버그가 적은 소프트웨어를 생산한다.

<img src="/Users/nys/workspace/study/good-c-bad-c/chapter01/고품질_코드.png" width="600" />

- 좋은 소프트웨어인지 그렇지 않은지는그 모든 작은 결정들이 모여서 이루어진다.
- 이 장에서는 고품질 코드가 달성해야 할 네 가지 목표를 살펴본다.
- 그다음 작성한 고품질인지 확인하기 위해 일상 업무에서 사용할 수 있는 여섯 가지 고차원 전략으로 확장한다.



## 1.1 코드는 어떻게 소프트웨어가 되는가

- 코드베이스(codebase): 소프트웨어를 빌드할 수 있는 코드가 저장된 저장소(repository)
- 코드 제출(submitting code)
- 코드 검토(code review)
- 제출 전 검사(pre-submit check)
- 배포(release)
- 프로덕션(production)



## 1.2 코드 품질의 목표

- 코드 품질의 목표는 더 나은 소프트웨어를 만드는 것이다.
- 코드를 고품질 혹은 저품질로 정의하는 것은 본질적으로 주관적이고 다소 성급한 것이다.
- 좀 더 객관적이 되기 위해선 한 발짝 뒤로 물러서서 코드를 통해 정말로 달성하려는 것이 무엇인지 생각해보는 것이 유용하다는 것을 알게 됐다.
- 이러한 것을 달성하는데 도움이 되면 그 코드는 높은 품질의 코드이고, 방해된다면 낮은 품질의 코드다.



#### 네 가지 상위 수준의 목표

1. 작동해야 한다.
2. 작동이 멈춰서는 안 된다.
3. 변화하는 요구 사항에 적응해야 한다.
4. 이미 존재하는 기능을 또다시 구현해서는 안 된다.



### 1.2.1 코드는 작동해야 한다

- 우리가 코드를 작성하는 이유는 문제를 해결하기 위함이다.
- 코드는 우리가 해결하려고 하는 문제를 실제로 해결해야 한다.
- 이것은 또한 버그가 없다는 것을 의미하는데, 버그가 존재하면 코드가 제대로 작동하지 않고 문제를 완전히 해결하지 못할 가능성이 있기 때문이다.
- 코드가 '작동한다' 라는 것을 정의할 때 문제가 특별히 성능 향상에 관한 것이라면 코드가 그에 맞게 수행되도록 하는 것은 요구 사항의 일부를 충족하는 것이다. 보안과 같은 고려사항도 마찬가지다.



### 1.2.2 코드는 작동이 멈추면 안 된다

- 어떻게 해야 내일 혹은 1년 후에도 여전히 작동하게 할 수 있을까?
- 변화하는 환경과 요구 사항에도 불구하고 계속 작동하는 코드를 만드는 것은 훨씬 더 어렵다.



### 1.2.3 코드는 변경된 요구 사항에 적응할 수 있어야 한다.

- 한 번 작성하고 다시는 수정되지 않는 코드는 거의 없다.
- 적응 가능한 코드를 작성하기 위해 얼마나 많은 노력을 기울여야 할지에 대해 균형 잡힌 결정을 내리는 것은 까다롭다.
- 요구 사항이 어떻게 변할 것인지는 정확히 알 수 없다.
- 코드나 소프트웨어가 시간이 지남에 따라 어떻게 변할지 완벽하고 정확하게 예측하는 것은 불가능하다.
- 대신 우리는 이 두 극단의 중간 어딘가에서 접근법을 찾아야 한다.



### 1.2.4 코드는 이미 존재하는 기능을 중복 구현해서는 안 된다

- 문제를 해결하기 위해 코드를 작성할 때 일반적으로 큰 문제를 여러 개의 작은 하위 문제로 나눈다.
- 코드를 재사용함으로써 우리는 그들의 전문지식과 향후 있을 업데이트를 받을 수 있다.
- 마찬가지로 어떤 하위 문제를 해결하기 위해 자신이 이미 코드를 작성했다면, 다른 개발자들이 동일한 문제를 해결하기 위해 자신만의 코드를 다시 작성하지 않도록 쉽게 재사용할 수 있는 방식으로 코드를 구성해야 한다.



## 1.3 코드 품질의 핵심 요소

1. 코드는 읽기 쉬워야 한다.
2. 코드는 예측 가능해야 한다.
3. 코드를 오용하기 어렵게 만들라.
4. 코드를 모듈화하라.
5. 코드를 재사용이 가능하고 일반화할 수 있게 작성하라.
6. 테스트가 용이한 코드를 작성하고, 제대로 테스트하라.



### 1.3.1 코드는 읽기 쉬워야 한다

#### 코드를 읽을 때 이해하기 위해 애쓰는 사항

- 코드가 하는 일
- 어떻게 그 일을 수행하는지
- (입력이나 상태 등)어떤 것을 필요로 하는지
- 코드 실행 결과물



- 코드의 가독성이 떨어진다면, 다른 개발자가 그 코드를 이해하는 데 많은 시간을 들여야 한다. 또한, 코드의 기능에 대해 잘못 이해하거나 몇 가지 중요한 세부 사항을 놓칠 가능성 역시 크다.
- 소프트웨어가 수행하는 모든 일은 그것을 가능하게 하는 어떤 코드에 의해 일어난다. 그 코드가 무엇을 하는지 개발자가 이해하지 못하면, 소프트웨어 전체가 제대로 작동하는 것은 거의 불가능에 가깝다.



### 1.3.2 코드는 예측 가능해야 한다

- 우리의 코드를 사용하는 다른 개발자는 이름, 데이터 유형, 일반적인 관행과 같은 단서를 사용해 코드가 입력값으로 무엇을 예상하는지, 코드가 무슨 일을 하는지, 그리고 무엇을 반환하는지에 대한 정신 모델을 구축한다.
- 코드가 예상에서 벗어나는 일을 한다면, 그 코드를 사용하는 개발자는 그 상황을 알지 못하거나 그 상황에 대처할 생각을 하지 못할 것이다.
- 코드가 예상을 벗어나는 일을 수행하지는 않는지 주의깊게 살펴야 하고, 할 수 있다면 그런 코드를 작성하지 않도록 노력해야 한다.



### 1.3.3 코드를 오용하기 어렵게 만들라

- 호출할 때 인수가 입력되거나 시스템이 특정 상태에 있을 것을 예상한다. 자신이 작성한 코드에 잘못된 것들이 꽂히면, 모든 것이 폭발할 수 있다.
- 코드를 오용하기 어렵거나 불가능하게 하면 코드가 작동할 뿐만 아니라 계속해서 잘 작동할 가능성을 극대화할 수 있다.



### 1.3.4 코드를 모듈화하라

- 모듈화는 개체나 시스템의 구성 요소가 독립적으로 교환되거나 교체될 수 있음을 의미한다.
- 모듈화된 시스템의 주요 특징 중 하나는 인터페이스가 잘 정의되어 서로 다른 구성 요소 간 상호작용하는 지점이 최소화된다는 점이다.
- 코드를 외부에 의존하지 않고 실행할 수 있는 모듈로 나누는 것이 이로울 때가 많다. 이때 두 개의 인접한 모듈 사이의 상호작용은 한 곳에서 일어나고 잘 정의된 인터페이스를 사용한다.



### 1.3.5 코드를 재사용 가능하고 일반화할 수 있게 작성하라

- 재사용성(reuseability)
  - 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있음을 의미
- 일반화성(generalizability)
  - 개념적으로는 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미
- 코드베이스에서 코드 라인이 적을수록 좋다는 것이다.



### 1.3.6 테스트가 용이한 코드를 작성하고 제대로 테스트하라

- 테스트는 두 가지 핵심 사항에 대한 방어 수단이 될 때가 많다.
  - 버그나 제대로 동작하지 않는 기능을 갖는 코드가 코드베이스에 병합되지 않도록 방지
  - 버그나 제대로 동작하지 않는 기능을 갖는 코드가 배포되지 않도록 막고 서비스 환경에서 실행되지 않도록 보장
- 테스트는 버그와 제대로 동작하지 않는 기능이 코드베이스로 유입될 가능성을 최소화하고, 실제 서비스 환경에 배포되지 않도록 하기 위해 반드시 필요하다.

#### 테스트 용이성(testability)

- 테스트 용이성은 모듈화와 깊은 관련이 있으며, 모듈화된 코드(또는 시스템)는 테스트 용이성이 더 좋다.
- 테스트 용이성을 확인하기 위해 코드를 작성하면서 '어떻게 테스트할 것인가?'를 계속 자문하는 것이 좋다. 즉, 코드를 다 작성하고 나서 테스트에 대해 생각해서는 안 된다. 테스트는 코드 작성의 모든 단계에서 필수적이고 기본적인 부분이다.



## 1.4 고품질 코드 작성은 일정을 지연시키는가?

- 한번 사용하고 버릴 사소한 유틸리티성 프로그램이 아닌 좀 더 중요한 소프트웨어를 개발하고 있다면, 일반적으로 고품질 코드를 작성하는 것이 중장기적으로는 개발 시간을 단축해준다.
- 떠오르는 대로 코딩하면 처음에는 시간을 절약할 수 있다. 그러나 이런 코드는 머지않아 취약하고 복잡한 코드베이스로 귀결될 것이며, 점점 더 이해하기 어렵고 추론할 수 없는 코드가 된다.