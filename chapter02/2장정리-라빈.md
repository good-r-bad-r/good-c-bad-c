# 추상화 계층
우리는 스스로 의식하지는 못하지만 상위 수준의 문제를 풀 때 보통 문제를 여러 개의 작은 하위 문제들로 나눈다.

예를 들어 ```모든 기능을 하나의 거대한 함수나 클래스로 구현할 것인가, 아니면 여러개의 함수나 클래스로 나눠야 하는가?``` 나눠야 한다면 ```어떻게 나눠야 하는가?```
코드를 구성하는 방법은 코드 품질의 기본적인 측면 중 하나이며, 코드를 잘 구성한다는 것은 간결한 ```추상화 계층```을 만드는 것으로 귀결될 때가 많다.

## 2.1 널값 및 의사코드 규약
프로그래밍 언어는 값(또는 참조/포인터)이 없다는 개념을 가지고 있다. -> 널(null)
- 값이 제공되지 않거나 함수가 원하는 결과를 반환할 수 없는 경우가 자주 발생하기 때문에 '값이 없다' 또는 '부재하다'는 이 개념은 유용하다.
- 값이 널일 수 있거나 혹은 널이면 안 되는 경우가 항상 명백한 것은 아니라서 문제가 발생한다. 개발자들은 변수에 액세스하기 전에 널값인지 확인하는 것을 자주 잊어버린다. 

최근 몇 년 동안 ```널 안전성(null safety)``` 혹은 ```보이드 안전성(void safety)```에 대한 생각이 점점 더 많은 추진력을 얻고 있다. 이렇게 하면 널값이 가능한 변수나 반환값을 그에 맞게 표시해야 하고 컴파일러는 반드시 널값 여부 확인을 할 수밖에 없도록 만든다. 

사용 중인 언어가 널 안전성을 지원하지 않는다면, 널값을 사용하는 대신 ```옵셔널(Optional)``` 타입을 사용하는 것이 좋다.

## 2.2 왜 추상화 계층을 만드는가?
코드 작성은 복잡한 문제를 계속해서 더 작은 하위 문제로 세분화하는 작업이다. -> 추상화 계층(layers of abstraction)

**좀 더 일반적으로 말해서 어떤 문제를 하위 문제로 계속해서 나누어 내려가면서 추상화 계층을 만든다면, 같은 층위 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 댁발 코드는 특별히 복잡해 보이지 않을 것이다. 소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야 한다. 비록 문제가 엄청나게 복잡할지라도 하위 문제들을 식별하고 올바른 추상화 계층을 만듦으로써 그 복잡한 문제를 쉽게 다룰 수 있다.**

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소
- 가독성: 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다.
- 모듈화: 추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때, 다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다. 
- 재사용성 및 일반화성: 하위 문제에 대한 해결책이 간결한 추상화 계층으로 제시되면 해당 하위 문제에 대한 해결책을 재사용하기가 쉬워진다. 그리고 문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다. 
- 테스트 용이성: 코드가 추상화 계층으로 깨끗하게 분할되면 각 하위 문제에 대한 해결책을 완벽하게 테스트하는 것이 훨씬 쉬워진다.

## 2.3 코드의 계층
실제로 추상화 계층을 생성하는 방법은 코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성하는 것이다. 

### 2.3.1 API 및 구현 세부 사항
- 코드를 호출할 때 볼 수 있는 내용
  - 퍼블릭 클래스, 인터페이스 및 함수(메서드)
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(예: 호출 순서)
- 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항

API는 서비스를 사용할 때 알아야 할 것들에 대한 개념을 형식화하고, 서비스의 모든 구현 세부 사항은 이 API 뒤에 감춘다.

![그림 2.3](/chapter02/image1.png)

API는 호출하는 쪽에 공개할 개념만 정의하면 되고 그 이외의 모든 것은 구현 세부 사항이기 때문에 코드를 API의 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다. 코드의 일부를 작성하거나 수정할 때, (입력 매개변수, 반환 유형, 퍼블릭 함수를 통해) API에 이 수정 사항에 대한 구현 세부 정보가 새어 나간다면 추상화 계층이 명확하게 구분되어 이루어진 것이 아니다.

### 2.3.2 함수
각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다. 

함수가 하는 일을 다음 중 하나로 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성하기 위한 좋은 전략이 될 수 있다.
- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

일단 함수를 작성했으면 작성된 코드를 ```문장```으로 만들어보면 좋다. 문장을 만들기 어렵거나 너무 어색하면 함수가 너무 길다는 것을 의미하고 더 작은 함수로 나누는 것이 유익할 것이다.

함수를 작게 만들고 수행하는 작업을 명확하게 하면 코드의 가독성과 재사용성이 높아진다. 따라서 코드 작성을 일단 마치고 코드 검토를 요청하기 전에 자신이 작성한 코드를 비판적으로 다시 한번 살펴보는 것이 좋다. 함수를 한 문장으로 표현하기 어렵게 구현했다면 로직의 일부를 잘 명명된 헬퍼 함수로 분리하는 것을 고려해봐야 한다.

### 2.3.3 클래스
클래스의 이상적인 크기에 대한 경험 법칙
- 줄 수(number of lines): 때때로 ```300줄을 넘지 않아야 한다```는 가이드를 받을 수 있다.
  - 300줄 이하의 클래스는 무조건 적절한 크기임을 뜻하지는 않는다. 이것은 어떤 것이 잘못되었을지도 모른다는 경고의 역할만 할 뿐, 어떤 것이 옳다는 보장은 아니다. 
- 응집력(cohesion): 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 매우 응집력이 강하다.
  - 순차적 응집력: 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생한다.
  - 기능적 응집력: 몇 가지 요소들이 모여서 하나의 일을 성취하는 데 기여할 때 발생한다. ```하나의 일(single task)```이 무엇인가에 대한 정의는 매우 주관적일 수 있다. 
- 관심사의 분리(separation of concerns): 시스템이 각각 별개의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙이다. 두 가지 항목이 분리되어 있으면 다른 항목을 업그레이드할 필요 없이 한 항목을 업그레이드 할 수 있다.

응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 ```하나의 사항```으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다. 이것은 매우 주관적일 수 있기 때문에 종종 보기보다 까다로울 수 있다.
-> 기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 한다. 

우리가 근본적으로 성취하려고 하는 것:
- 코드 가독성: 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다.
- 코드 모듈화: 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나다. 하위 문제에 대한 해결책이 하나의 클래스로 구현되어 있고, 다른 클래스와의 상호작용을 잘 준비된 몇가지 퍼블릭 함수를 통해서만 이루어진다면, 그 하위 문제에 대한 해결책의 구현을 다른 클래스로 교체할 필요가 있을 때 이것을 쉽게 할 수 있다. 
- 코드 재사용성 및 일반화: 두 하위 문제에 대한 해결책을 한 클래스로 묶어 놓으면 다른 누군가가 이미 구현된 한 가지 해결책을 재사용할 기회가 줄어든다.
- 테스트 용이성 및 적절한 테스트: 로직이 여러 클래스로 나누어지면 각 부분을 적절하게 테스트하기가 훨씬 쉬워진다. 

코드를 적절한 크기의 클래스로 쪼개지 않으면 너무 많은 개념을 한꺼번에 다루고, 가독성이 떨어지며 모듈화가 덜 이루어지고, 재사용과 일반화가 어렵고, 테스트하기가 어려워진다.

관련 하위 문제를 해결하는 것이 원래 문제와는 다른 관심사인지 아니면 본질적으로 원래 문제의 일부분으로 간주하여야 하는지에 대해서는 의견이 다르다. 이 클래스가 분리되어야 할지 판단하기 위해서는 이 클래스가 어떻게 네 가지 핵심 요소에 반하여 작성되어 있는지 살펴보는 것이 더 나을 수도 있다.

```테스트를 위해 퍼블릭으로 함``` -> 주석문을 덧붙일 수 있지만, 이는 다른 개발자의 인지 부담을 가중할 뿐이다. 

너무 많은 일을 하는 거대한 클래스를 코드베이스에서 흔히 볼 수 있는데, 코드 품질의 저하로 이어질 때가 많다. 클래스 구조를 설계할 때 코드 품질의 네 가지 핵심 요소를 충족하는지 신중하게 생각하면 좋다. 코드를 적절한 크기의 클래스로 세분화하는 것은 추상화 계층을 잘 만들기 위한 가장 효과적인 도구이기 때문에 이를 위한 시간과 노력을 들일 많나 가치가 충분히 있다.

### 2.3.4 인터페이스
계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해 사용할 수 있는 한 가지 접근법은 어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정하는 것이다. 이보다 위에 있는 계층은 인터페이스에 의존할 뿐 로직을 구현하는 구체적인 클래스에 의존하지 않는다.

하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 향후 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다.

주어진 추상화 계층에 대해 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없더라도 여전히 인터페이스를 통해 추상화 계층을 표현해야 하는가는 여러분과 팀이 결정할 사안이다.

인터페이스로 도출한 하나의 구체 클래스의 장점:
- 퍼블릭 API를 매우 명확하게 보여준다: 이 계층에서 사용해야 하는 기능과 사용하지 말아야 하는 기능에 대해 혼동할 일이 없다.
- 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다: 원래 코드를 작성할 때는 또 다른 구현이 필요하지 않을 것이라고 확신하더라도 한두 달 후에는 이러한 가정이 잘못된 것으로 판명될 수 있다.
- 테스트를 쉽게 할 수 있다: 테스트 중에 목(mock)이나 페이크 객체로 대체할 수 있다. 
- 같은 클래스로 두 가지 하위 문제를 해결할 수 있다: 한 클래스가 두 개 이상의 서로 다른 추상화 계층에 구현을 제공할 수 있다.

인터페이스의 단점:
- 더 많은 작업이 필요하다: 인터페이스를 정의하려면 코드를 더 작성해야 한다(파일도 새로 필요할 것이다).
- 코드가 복잡해질 수 있다: 다른 개발자가 코드를 이해하려고 할 때, 논리를 탐색하는 것이 어려울 수 있다.

인터페이스를 정의하지 않더라도 클래스에서 어떤 함수를 퍼블릭으로 노출할지 매우 신중하게 생각해야 하며 구현 세부 사항이 유출되지 않도록 해야 한다. 일반적으로 클래스를 작성하거나 수정할 때마다 나중에 필요한 경우 인터페이스를 붙이는 것이 어려워지지 않도록 코드를 작성해야 한다.

### 2.3.5 층이 너무 얇아질 때
코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.
- 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드(boilerplate code)로 인해 코드의 양이 늘어난다.
- 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
- 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.

코드 계층의 규모를 올바르게 결정하는 것은 중요하다. 코드베이스에 의미 있는 추상화 게층이 없으면 전혀 관리할 수 없는 코드가 된다. 계층이 있더라도 각 계층이 너무 크면 쪼개져야 할 여러 추상화가 한 계층으로 병합되어 결국은 모듈화되지 않고, 재사용할 수 없으며, 가독성이 낮은 코드가 된다. 반면 계층을 너무 얇게 만들면 단일 계층으로 만들어도 될 것을 둘로 분해한 것이고, 이것은 불필요한 복잡성을 초래할 수 있다. 또한, 인접한 계층들이 원래 되어야 하는 대로 잘 분리되지 않았음을 의미할 수도 있다. 일반적으로 너무 많은 일을 하는 계층은 너무 적은 일을 하는 계층보다 더 문제가 될 수 있다. 따라서 어떤 것이 더 나을지 확실하지 않다면, 너무 많은 계층을 남용하는 결과를 가져오더라도 계층을 여러 개로 나누는 것이 한 계층 안에 모든 코드를 집어넣는 것보다 낫다.

앞서 클래스를 통해 살펴봤던 것처럼 계층이 너무 두거운지 여부를 결정해주는 단 하나의 규칙이나 조언은 존재하지 않는다. 왜냐하면 계층을 몇 개로 나눌지는 해결하려고 하는 실제 현실의 문제에 달려 있기 때문이다. 

## 2.4 마이크로서비스는 어떤가?
마이크로서비스 아키텍처에서는 개별 문제에 대한 해결책이 단지 단일 프로그램으로 컴파일되는 라이브러리 수준이 아니라 독립적으로 실행되는 서비스로 배포된다. 

마이크로서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만, 서비스를 구현하기 위해 여러 하위 문제를 해결해야 한다는 사실은 바뀌지 않는다. 올바른 추상화 및 코드 계층을 만드는 것은 여전히 중요하다.
